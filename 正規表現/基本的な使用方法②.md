# 正規表現のさまざまなパターン

subメソッド、matchメソッドの基本的な使い方を学習しました。ここからは正規表現のさまざまなパターンを使い、より応用的な使用方法を見ていきましょう。
今回紹介するパターンは以下の3つです。

- 電話番号のハイフンを取り除く
- パスワードに英数字８文字以上という制約を設定する
- メールアドレスからドメインの部分のみ抽出する

## 電話番号のハイフンを取り除く

特定の文字を取り除く場合は、「特定の文字を空文字に置換する」と考えます。
置換するメソッドはsubメソッドでした。しかしながら、subメソッドでは最初のハイフンしか置換されません。そこで`gsubメソッド`を用いることにします

## gsubメソッド

`g`が意味するのはグローバルマッチという言葉です。文字列内に指定した文字が複数含まれている場合、その全てを置換するという意味になります。
gsubではなくsubを使用した場合、最初にマッチした１つだけが置換されます。

###  電話番号からハイフンを取り除いてみる

```ターミナル
irb(main):001:0> tel = '090-1234-5678'
=> "090-1234-5678"

irb(main):002:0> tel.sub(/-/,'')
=> "0901234-5678"
# 最初のハイフンしか置換されない

irb(main):003:0> tel.gsub(/-/,'')
=> "09012345678"
```

## パスワードに英数字８文字以上という制約を設定する

今回はパスワードの条件を「大文字小文字は両方可能で、英字もしくは数字8文字以上であること」とします。設定するパスワードは「Hoge1234」とします。
matchメソッドを使用して以下のように記述します。

```ターミナル
irb(main):001:0> pass = 'Hoge1234'
=> "Hoge1234"

irb(main):002:0> pass.match(/[a-z\d]{8,}/i)
=> #<MatchData "Hoge1234">
```

今度は、パスワードの文字を1文字減らしてみましょう。

```ターミナル
irb(main):001:0> pass = 'Hoge123'
=> "Hoge123"

irb(main):002:0> pass.match(/[a-z\d]{8,}/i)
=> nil
```

結果がnilとなったので、確かに8文字以上の英数字でないとmatchしないことが確かめられました。
実際によくある処理としては、この結果がnilであればWebサイトのパスワードとして認めないようにする、といったものが例として挙げられます。

以下の5つについて解説します。

- [ ]
- a-z
- \d
- {n, m}
- i

##  [ ]

正規表現における`[ ]`（角括弧）は、`[ ]`で囲まれた文字のうちいずれか1つにマッチすることを確認します。

##  a-z

`-`（ハイフン）を使用することで範囲を設定することができ、a-zは「アルファベットのaからzまで」という意味になります。
また、`[ ]`と組み合わせることで、`[a-z]`は「アルファベットのaからzまでのいずれか1つにマッチ」という意味になります。

```ターミナル:a~cの英字を抽出
irb(main):001:0> 'dog'.match(/[a-c]/)
=> nil
```

「dog」という単語にはa ~ cのどの英字も含まれていないのでマッチしません。

## \d

このdは数字を表します。数字を表すdのような文字を特殊文字と呼びます。特殊文字を使用する場合は直前に\を記述するというルールが存在します。
今回は、\dは角括弧の内部にあるので、[a-z\d]は**英数字のいずれか１つにマッチ**という意味になります。

```ターミナル:数字のみ抽出する
irb(main):001:0> 'I have 3 pens'.match(/\d/)
=> #<MatchData "3">
```

##  {n, m}

直前の文字が少なくとも n 回、多くても m 回出現するものにマッチすることを確認します。したがって、文字数の制約を追加することができます。
例えば、{8, }は、直前の文字が少なくとも８回出現するものにマッチという意味になります。
今回、波括弧の直前は[a-z\d]でした。つまり、**英数字のいずれか１つが少なくとも８回出現するものにマッチ**という意味になります。

```ターミナル:少なくとも４回、多くても６回出現するものにマッチ
irb(main):001:0> '12345678'.match(/\d{4,6}/)
=> #<MatchData "123456">

irb(main):002:0> '123'.match(/\d{4,6}/)
=> nil
```

##  i

最後にiオプションを加えることで大文字・小文字を区別せずに検索します。
iオプションを付けない場合では、`[a-z]と小文字で記述しているので大文字にマッチ`しなくなってしまいます。
逆に小文字のみという制約にする場合は、iオプションを付けないことで対応できます。

```ターミナル:大文字・小文字の区別
irb(main):003:0> 'Cat'.match(/cat/)
=> nil

irb(main):004:0> 'Cat'.match(/cat/i)
=> #<MatchData "Cat">
```

## メールアドレスからドメインの部分のみ抽出する

「hoge@tech-camp.com」というアドレスから「@tech-camp.com」の部分のみを取得してみます。

※matchメソッドを使用することで抽出することができます。

```ターミナル
irb(main):001:0> mail = 'hoge@tech-camp.com'
=> "hoge@tech-camp.com"

irb(main):002:0> mail.match(/@.+/)
=> #<MatchData "@tech-camp.com">
```

以下の2つについて解説します。

- .
- +

##  .

ハイフンやピリオドなど含めた全ての英数字において、どの１文字にもマッチします。

```ターミナル
irb(main):001:0> 'hoge'.match(/./)
=> #<MatchData "h">
```

##  +

直前の文字が１回以上の繰り返しにマッチします。

```ターミナル
irb(main):001:0> 'aaabb'.match(/a+/)
=> #<MatchData "aaa">
```

これらを踏まえると、.+は何かしらの文字が１回以上繰り返すものにマッチします。
先頭に@を付けることで`＠から始まり、何かしらの文字が１回以上繰り返すものにマッチ`という意味になります。
こうすることでメールアドレスからドメイン部分のみを抽出することができます。
もしも「@ ~」という文字列ではなかった場合に、メールアドレスとしての登録を認めない、という処理に応用できます。

