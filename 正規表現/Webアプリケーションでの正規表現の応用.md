# Ruby on Railsにおけるバリデーションへの応用

Ruby on Railsでもよく使われる以下の3つを例に挙げて解説します。

- 郵便番号
- 全角かな/カナ漢字の区別
- passwordの英数混合の判断

## 郵便番号について

郵便番号は、3桁の数字とハイフンと4桁の数字で構成されています。ユーザーが正しくハイフンが記入された正しい形式で郵便番号を入力しているかを判別する方法です。

この郵便番号を正規表現らしく言い換えると、先頭に3桁の数字、そしてハイフン、末尾に4桁の数字 となります。

```irb
irb(main):001:0> postal_code = "150-0044"

irb(main):002:0> postal_code.match(/\A\d{3}[-]\d{4}\z/)
=> #<MatchData "150-0044">
```

以下の3つについて解説します。

- {n}
- \A
- \z

##  {n}

直前の文字が n 回出現する場合にマッチします。
例えば、a{5}は、「『a』という文字が5回出現するものにマッチする」という意味になります。
今回はハイフンを挟んでd{3}とd{4}なので、ハイフン前は「数字が3回出現するものにマッチする」、ハイフン後は「数字が4回出現するものにマッチする」という意味になります。

## \A

\Aの直後に置いた文字を、文字列の先頭に持つ場合にマッチします。

今回は\A\d{3}としているので、文字列の先頭に3桁の数字があるとマッチします。postal_codeの先頭は150ですので正しくチェックできています。

## \z

\zの直前に置いた文字を、文字列の末尾に持つ場合にマッチします。

今回は\d{4}\zとしているので、文字列の末尾に4桁の数字があるとマッチします。postal_codeの末尾は0044ですので正しくチェックできています。

モデルには、実際には以下のように記述してバリデーションを設けます。

```ruby:Railsのモデル
validates :postal_code, format: { with: /\A\d{3}[-]\d{4}\z/, message: 'を入力してください' }
```

## 全角かな/カナ漢字の区別について

全角かな/カナ、もしくは漢字を区別するためには、アルファベットをチェックするときに使った[a-z]のように表現します。

```irb
irb(main):001:0> full_name = "山田はな子"

irb(main):002:0> full_name.match(/\A[ぁ-んァ-ヶ一-龥々ー]+\z/)
=> #<MatchData "山田はな子">

irb(main):003:0> full_name = "田中メアリー"

irb(main):004:0> full_name.match(/\A[ぁ-んァ-ヶ一-龥々ー]+\z/)
=> #<MatchData "田中メアリー">

irb(main):005:0> full_name = "yamadaハナ子"

irb(main):006:0> full_name.match(/\A[ぁ-んァ-ヶ一-龥々ー]+\z/)
=> nil
```

##  [ぁ-んァ-ヶ一-龥々ー]

かな/カナ、または漢字についても[a-z]同様に[ぁ-んァ-ン一-龥]と表現することで、「ぁ」から「ん」まで、「ァ」から「ン」まで、「一」から「龥」までの文字でチェックを行います。
これらの文字の範囲は、Unicodeにおける範囲であり、上記の範囲が一般的に指定されます。ただし、[ぁ-んァ-ン一-龥]と表現すると、「ヴ、ヵ、ヶ、々」という文字が弾かれてしまいます。
なぜなら、utf-8文字コード上で「ヴ」「ヵ」「ヶ」はカタカナ「ン」の後に配列されているためです。そのため「ァ-ヶ」と記載しています。

また「々」はutf-8文字コード上で記号として認識されているため、別途「々」の指定を追加する必要があります。
そのため、[ぁ-んァ-ン一-龥]ではなく、[ぁ-んァ-ヶ一-龥々]と表現することで、あらゆる日本語に対応する言葉ができます。

さらに、長音記号が含まれた文字列を区別する場合を考えましょう。例えば「メアリー」や「ジョニー」のような文字列です。
このような長音を区別する場合は、[ぁ-んァ-ヶ一-龥々]の末尾に「ー」を追記して、`[ぁ-んァ-ヶ一-龥々ー]`と記載します。

```irb
irb(main):003:0> full_name = "田中メアリー"

irb(main):004:0> full_name.match(/\A[ぁ-んァ-ヶ一-龥々ー]+\z/)
=> #<MatchData "田中メアリー">
```

これらを踏まえて、再度、例のコードを確認します。
今回は名前全体がかな/カナ/漢字であるかをチェックしたいので、先に出てきた\Aと\zと+を同時に用いて、先頭から末尾までかな/カナ/漢字である場合にのみマッチします。
3つ目のチェックには先頭にyamadaとアルファベットを使用していますので、マッチしておらずnilが返ってきています。

```irb
irb(main):005:0> full_name = "yamadaハナ子"

irb(main):006:0> full_name.match(/\A[ぁ-んァ-ヶ一-龥々ー]+\z/)
=> nil
```

これにより、正しく正規表現で区別できていることがわかります。

モデルには、実際には以下のように記述してバリデーションを設けます。

```ruby:Railsのモデル
with_options presence: true, format: { with: /\A[ぁ-んァ-ヶ一-龥々ー]+\z/, message: '全角文字を使用してください' } do
  validates :first_name
  validates :last_name
end
```

## passwordの英数字混合の判断について

次は英数字混合のチェックです。**英数字が混合したパスワードであるか**という項目となります。

英数字は[a-z\d]でチェックできることを確認しました。
チェックするのがパスワードであることから、英字もしくは数字が少なくとも0回以上続き、末尾までそれが続くことが前提条件となります。

以下の2つについて解説します。

- ?=
- *?

## ?=

?=の直後に設定した文字でチェックをかけて、設定した文字が続く文字列が存在する場合、その文字列にマッチします。

```irb
イメージが湧きやすいように、下記の例をご覧ください。

irb(main):001:0> name = "マイケルジョーダン"

irb(main):002:0> name.match(/マイケル(?=ジョーダン)/)
=> #<MatchData "マイケル">

irb(main):003:0> name = "マイケルジャクソン"

irb(main):004:0> name.match(/マイケル(?=ジョーダン)/)
=> nil
```

このように同じマイケルから始まる文字列でも、後ろに続く文字が違うと結果が変わります。
今回の場合はジョーダンが後ろに続く場合にのみマッチするように設定したので、2度目のチェックにはマッチせずnilが返ってきています。

##  *?

「*」は、直前の1文字が0回以上続くとマッチします。例えば、「camp*」とした場合、「cam」「camp」「campp」「camppp」などがマッチします。
この「*」の後に?をつけることで、チェックした文字列の中で、?の直後の文字が出てきた段階でその1文字のみ返します。

以上を踏まえて、`/\A(?=.*?[a-z])(?=.*?[\d])[a-z\d]+\z/i`の意味を確認しましょう。

## バリデーションの意味を理解する

以下の順番でバリデーションの意味を確認しましょう。

![image](https://github.com/koharayuki/til/assets/132040884/009bb182-b40a-4117-a74d-9d015ce90ddb)

### `①-aについて`

| パターン | 意味                                |
| ------ | ---------------------------------- |
| .	     | 改行コード以外のどの1文字にもマッチ         |
| [a-z]  | 角括弧で囲まれた文字のいずれか 1個にマッチ  |

つまり、①-aの意味は、「**改行以外の文字が0回以上続いたあとの英字1文字にマッチ**」となります。

### `①-bについて`

| パターン | 意味                                |
| ------ | ---------------------------------- |
| .	     | 改行コード以外のどの1文字にもマッチ         |
| \d	   | 数字にマッチ                          |

### `②について`

| パターン | 意味                                |
| ------ | ---------------------------------- |
| \A	   | 直後の文字が先頭にある文字列にマッチ       |

つまり、②の意味は、①-a・①-bを踏まえると、「**改行以外の任意の文字0回以上とaからzの1文字（ここまでが①-a）の先頭位置、
かつ、改行以外の任意の文字0回以上と数字1文字（ここまでが①-b）の先頭位置にマッチするもの**」となります。

### `③について`

| パターン | 意味                                |
| ------ | ---------------------------------- |
| \z	   | 直前の文字が末尾にある文字列にマッチ       |

つまり、③の意味は、②を踏まえると、「**先頭が任意の文字0回以上と英数字ではじまっていて（ここまでが②）、末尾が英数字の1回以上の連続する文字列にマッチし、大文字小文字の区別がない**」となります。

モデルには、実際には以下のように記述してバリデーションを設けます。

```ruby:Railsのモデル
PASSWORD_REGEX = /\A(?=.*?[a-z])(?=.*?[\d])[a-z\d]+\z/i.freeze
validates_format_of :password, with: PASSWORD_REGEX, message: 'には英字と数字の両方を含めて設定してください' 
```

※.freezeは、PASSWORD_REGEXという変数が編集されないようにするメソッドです。正規表現とは関係ありません。

(公式ドキュメントURL:https://docs.ruby-lang.org/ja/latest/method/Object/i/freeze.html)


# 正規表現のパターン表記一覧


| パターン           | 意味                                                     |
| ---------------- | -------------------------------------------------------- |
| [a-z]		         | 角括弧で囲まれた文字のいずれか 1個にマッチ                       |
| \d	        	   | 数字にマッチ                                                |
| {n, m}	         | 直前の文字が少なくともn回、多くてもm回出現するものにマッチ             |
| {n}			         | 直前の文字がn回出現するものにマッチ                             |
| .	  		         | 改行以外のどの1文字にもマッチ                                  |
| +	     		       | 直前の文字の1回以上の繰り返しにマッチ                            |
| \A			         | 直後の文字が先頭にある文字列にマッチ                             |
| \z	  	         | 直前の文字が末尾にある文字列にマッチ                             |
| [ぁ-んァ-ヶ一-龥々]  | 角括弧に囲まれたかな、カナ、漢字のいずれかにマッチ（ヴ、ヵ、ヶ、々を含む）    |
| ?=		  	       | 直後に設定した文字が続く文字列にマッチ                            |
| *?		 	         | 直前に設定した文字が0回以上続く文字列にマッチ                      |

