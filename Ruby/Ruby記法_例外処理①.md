# 処理が失敗したときに行う処理

## 期待していない結果に対応しよう

これまでのアプリケーション開発では、「テストして問題を先に見つけたり、エラーが起これば、それを修正する」ということを繰り返していました。
しかし、プログラムは正しく組まれていても、アクセスの集中や異常値の入力など、さまざまな環境やユーザーの予期せぬ動作による影響でエラーを引き起こしてしまうことがあります。

このように、プログラムで意図した結果が得られなかった場合、その結果や状況は**例外**と呼ばれます。

###  例外

例外とは、ある処理を実行した際の結果が、期待されるものと異なる状況を指します。簡単に言えばエラーのことです。RubyおよびRuby on Railsでは、`Exception`というクラスを継承する形でさまざまな例外が定義されています。
ここまでよく見てきた`NoMethodError`、`SyntaxError`などは、すべてExceptionクラスの子孫クラスであり、例外です。例外が発生すると、それ以降の処理は中止され、実行されなくなってしまいます。

この例外による処理の不具合は、あらかじめ例外を予期しておき、例外が発生した際に行う例外処理を定義しておくことで対処できます。

### 例外処理

例外となる結果を得たときに行う処理のことです。
通常行いたかった処理とは別で、例外が起こった際に行う別の処理を仕込んでおき、緊急事態を早期復旧させたり、大きな問題へ発展する前から対処できるようにします。


# 例外処理の実装

今回はRailsアプリを使って、例外処理の方法を2パターン紹介します。

1.メインの処理に失敗したらそのときだけ別の処理を実行して、そのままメインの処理を続ける

2.メインの処理に失敗したらそのときだけ別の処理を実行して、メインの処理すべてをなかったことにして中止する


※**以下、サンプルアプリケーションを使用しながら補足していく**。


###  テーブルに初期データを追加する。

```ターミナル
# 初期データの投入
% rails db:seed
```

`rails db:seedコマンド`は、db/seeds.rbの記述に基づいて、**データベースにレコードを作成する**コマンドです。
`動作確認のために投入しておきたい初期データがある場合`に利用します。すでにテーブルでレコードが作成されていることを確認しておきましょう。

![image](https://github.com/koharayuki/til/assets/132040884/2ee0091f-daab-41b4-b4bb-c702082813ba)

データを投入するための記述があるseeds.rbを確認してみましょう。

```db/seeds.rb
users = []
10000.times do |i|
 # usersに10000件新規ユーザーの情報を格納する
  users << User.new(name: "dummy-#{i+1}", ticket_count: 0)
end
# importメソッドの引数に配列を渡して、まとめてレコードを作成する
User.import users
User.find(500).update(ticket_count: 2147483647)
```

今回、初期データの作成に`activerecord-import`というGemを利用しています。
このGemで、モデルがimportというメソッドを使用できるようになり、配列を受け取ればまとめてレコードを作成できるようになります。

レコードを1つずつ大量に作成するのではなく、配列に大量の情報を格納して1回だけデータベースにアクセスすることで、通常通り10000回User.createするよりも高速に大量のレコードを作成できるためです。


# 必要な知識を確認する

このアプリケーションの仕様は「オンラインゲーム」で、「開発途中」の段階です。
現在、ユーザーの情報を格納しているusersテーブルのみ作成済みで、テーブル構造は次のようになっています。

| 保持している情報          | カラム名        | 型        | 制約         |
| --------------------- | ------------- | --------- | ----------- |
| ユーザーの名前           | name          | string    | null:false  |
| 所持しているチケットの枚数   | ticket_count  | integer   | なし         |

また、現時点で決まっている仕様は以下の通りです。

- ユーザーは、チケットを所持している
- チケットはゲームをプレイする度に1つ消費する
- アプリケーションに障害が発生してサービスが止まってしまった場合、障害解消後に全ユーザーへ補償のチケットを10枚発行する

今回は、この中でも3番目の仕様に注目しましょう。

### アプリケーションに障害が発生してサービスが止まってしまった場合、障害解消後に全ユーザーへ補償のチケットを10枚発行する

## Rakeタスク

タスクを簡単に実行できるRubyのツールです。Railsでも使用できるように仕組みが備えられています。

Rakeタスクを利用することで、アプリケーションのタスクがコマンドで実行可能です。
RailsでRakeタスクを使用するには、まず以下のコマンドでRakeファイルを作成し、そのRakeファイルの中に処理を記述します。

```ターミナル
# Rakeタスク用のRakeファイルを作成
% rails g task タスクファイル名
```

これで、`lib/tasks/ディレクトリ`にタスクファイル名`.rake`というファイルが作成されます。

### Rakeファイル内の処理の書き方を確認しましょう

処理の記述するにあたって、以下のメソッドの役割を確認しましょう。

| メソッド名               | 役割                                        |
| --------------------- | ------------------------------------------ |
| namespace do ~ end    | 複数のタスクをグループ分けして１つにまとめる          |
| desc                  | 説明の処理(descriptionの略)                  |
| tasc do ~ end         | タスクの内容　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　          |

書き方は、以下の通りです。

```Rakeファイルの中身
namespace :ここにグループ名を記述する do
  desc "ここに処理の説明を記述する"
  task タスク名: :environment do

         ここに実際のタスクを記述する

  end
end
```

## environmentメソッド

environmentメソッドは、「タスクの処理をアプリケーション環境に依存させた上で実行する」ということを可能にします。ここでいう「アプリケーション環境」とは、「Rails環境」のことです。Rails環境に依存させる（読み込まれる）ことで、Rails上に設定したモデルなどの情報を取り扱うことができます。
今回の場合、`Userモデル`を扱うにあたっての非常に重要な役割を果たしています。

Rakeファイルに処理を記述したあと、ターミナルで以下のようにコマンドを実行することで、タスクを実行できます。

```ターミナル
# Rakeタスクの実行
% rails namespaceの名前:taskの名前
```


# アプリケーションを確認しよう

現在のアプリケーションを確認し、どのように仕様を達成するための処理が実装されているのか確認しましょう。
すでにRakeタスクが作成されており、「全ユーザーにチケットを10枚発行する処理」は、`lib/tasks/distribute_ticket.rake`に定義されています。

```ruby:lib/tasks/distribute_ticket.rake
namespace :distribute_ticket do
  desc "全ユーザーのticket_countを10増加させる"
  task execute: :environment do
    User.find_each do |user|
      user.increment!(:ticket_count, 10)
    end
  end
end
```

## incrementメソッド

incrementメソッドは、カラム名と数字を引数に取り、引数の数だけカラムの値を増加させます。今回は、「ticket_countカラムの値を10増加させる」という意味です。

ターミナルから、このタスクを実行することで、usersテーブルにある全レコードのticket_countの値が10増加します。

一見問題なく見える処理ですが、現在の実装には大きな問題があります。

## 問題点

今回rails db:seedを実行して投入した初期データには、意図的に例外を発生させるための値を1つだけ投入させています。

seeds.rbの6, 7行目に注目してください。

```ruby:db/seeds.rb
# ticket_countをint型で許容できる最大の値にする
User.find(500).update(ticket_count: 2147483647)
```

このコードで、idが500のユーザーのticket_countを、2147483647に変更しています。

![image](https://github.com/koharayuki/til/assets/132040884/6d924751-bb94-464a-ba96-537a62e3981a)

これは、SQLのinteger型が許容できる最大の値であり、もし2147483647より大きな値を保存しようとすると`RangeError`という例外が発生し、保存に失敗します。

##  タスクを実行して例外を確認する

実際にticket_countの値を増やして、上限を超えた値となる例外を発生させます。

```ターミナル
# ticket_countカラムの値を10増加させるタスクを実行
% rails distribute_ticket:execute
```

タスク処理が行われると「ticket_countカラムの値が10増加」されます。
処理を終えると、テーブルの状態は以下のようになります。

![image](https://github.com/koharayuki/til/assets/132040884/6dbe67b5-4e39-4b6b-b6a1-9a8ae6e1496d)

idが499までは問題なくticeket_countが10増加し、例外の発生するidが500番目以降のユーザーについては、処理が中止され、ticket_countが増えていないことがわかります。

