# 処理が失敗したときに行う処理

## 期待していない結果に対応しよう

これまでのアプリケーション開発では、「テストして問題を先に見つけたり、エラーが起これば、それを修正する」ということを繰り返していました。
しかし、プログラムは正しく組まれていても、アクセスの集中や異常値の入力など、さまざまな環境やユーザーの予期せぬ動作による影響でエラーを引き起こしてしまうことがあります。

このように、プログラムで意図した結果が得られなかった場合、その結果や状況は**例外**と呼ばれます。

###  例外

例外とは、ある処理を実行した際の結果が、期待されるものと異なる状況を指します。簡単に言えばエラーのことです。RubyおよびRuby on Railsでは、`Exception`というクラスを継承する形でさまざまな例外が定義されています。
ここまでよく見てきた`NoMethodError`、`SyntaxError`などは、すべてExceptionクラスの子孫クラスであり、例外です。例外が発生すると、それ以降の処理は中止され、実行されなくなってしまいます。

この例外による処理の不具合は、あらかじめ例外を予期しておき、例外が発生した際に行う例外処理を定義しておくことで対処できます。

### 例外処理

例外となる結果を得たときに行う処理のことです。
通常行いたかった処理とは別で、例外が起こった際に行う別の処理を仕込んでおき、緊急事態を早期復旧させたり、大きな問題へ発展する前から対処できるようにします。


# 例外処理の実装

今回はRailsアプリを使って、例外処理の方法を2パターン紹介します。

1.メインの処理に失敗したらそのときだけ別の処理を実行して、そのままメインの処理を続ける

2.メインの処理に失敗したらそのときだけ別の処理を実行して、メインの処理すべてをなかったことにして中止する


※**以下、サンプルアプリケーションを使用しながら補足していく**。


###  テーブルに初期データを追加する。

```ターミナル
# 初期データの投入
% rails db:seed
```

`rails db:seedコマンド`は、db/seeds.rbの記述に基づいて、**データベースにレコードを作成する**コマンドです。
`動作確認のために投入しておきたい初期データがある場合`に利用します。すでにテーブルでレコードが作成されていることを確認しておきましょう。

![image](https://github.com/koharayuki/til/assets/132040884/2ee0091f-daab-41b4-b4bb-c702082813ba)

データを投入するための記述があるseeds.rbを確認してみましょう。

```db/seeds.rb
users = []
10000.times do |i|
 # usersに10000件新規ユーザーの情報を格納する
  users << User.new(name: "dummy-#{i+1}", ticket_count: 0)
end
# importメソッドの引数に配列を渡して、まとめてレコードを作成する
User.import users
User.find(500).update(ticket_count: 2147483647)
```

今回、初期データの作成に`activerecord-import`というGemを利用しています。
このGemで、モデルがimportというメソッドを使用できるようになり、配列を受け取ればまとめてレコードを作成できるようになります。

レコードを1つずつ大量に作成するのではなく、配列に大量の情報を格納して1回だけデータベースにアクセスすることで、通常通り10000回User.createするよりも高速に大量のレコードを作成できるためです。


# 必要な知識を確認する

このアプリケーションの仕様は「オンラインゲーム」で、「開発途中」の段階です。
現在、ユーザーの情報を格納しているusersテーブルのみ作成済みで、テーブル構造は次のようになっています。











